# 一、UDP和TCP
## 5.2 用户数据报协议 UDP —— 无连接传输协议
### 5.2.1 UDP 的特点：是面向报文，无连接的，提供“尽力而为”服务  【和 TCP 都没有提供时延、带宽、安全性服务】
* 基于 IP 协议，只增加了多路复用/分用，及简单的错误校验（校验和）
* 是面向报文的：对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部。支持一对一、一对多、多对一和多对多的交互通信。
* 提供 “尽力而为”服务（IP 也是）：UDP 段可能丢失，非按序到达等
* 是无连接的：UDP 发送方和接收方之间不需要握手，每个UDP 段的处理独立于其他段。
### 5.2.2 UDP 的价值及应用
#### 1、无需建立连接（减少了延迟） 【DNS 使用 UDP】
#### 2、实现简单，无需维护链接状态
#### 3、头部开销小【8字节】
#### 4、没有拥塞控制  【应用可以更好地控制发送时间和速率】
#### 应用：常用于流媒体应用：容忍丢失、速度敏感；以及DNS 、SNMP等

### 5.2.3 UDP 首部格式 【8字节】：源端口、目的端口、长度、**检验和**
![](https://github.com/CyC2018/CS-Notes/raw/master/pics/d4c3a4a1-0846-46ec-9cc3-eaddfca71254.jpg)

* 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。
    * 长度：UDP 报文段的字节数（首部+数据）
    * 校验和：提供差错检验功能

## 5.3 传输控制协议 TCP 的首部格式 【20的固定字节 + 长度可变的选项】

![](https://github.com/CyC2018/CS-Notes/raw/master/pics/55dc4e84-573d-4c13-a765-52ed1dd251f9.png)

-  **序号**  ：用于对字节流进行编号。
    * （例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。）

-  **确认号**：期望收到的下一个报文段的序号。
    * (例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。)
    * 累计确认：该序列号之前的所有字节都已被正确接收

-  **数据偏移** ：即首部长度。
    * 指的是数据部分距离报文段起始处的偏移量。

-  **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。
    * TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。

-  **同步 SYN**  ：在连接建立时用来同步序号。
    * 当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。

-  **终止 FIN**  ：用来释放一个连接
    * 当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。

-  **窗口**  ：窗口值用于指示该接收方还有多少缓存空间，是接收方让发送方设置其发送窗口的依据。
    * 之所以要有这个限制，是因为接收方的数据缓存空间是有限的。
## 5.4 TCP —— 面向连接的传输协议
### 1、面向字节流 （把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）
### 2、面向连接   （发送数据之前必须建立连接，连接的状态只在连接的两端中维护）
#### 2.1 TCP 连接管理：三次握手机制 【客：SYN报文段->服：SYNACK报文段->客：ACK报文段】    ****

![](https://github.com/CyC2018/CS-Notes/raw/master/pics/e92d0ebc-7d46-413b-aec1-34a39602f787.png)


* 首先：服务器处于 LISTEN（监听）状态，等待客户的连接请求。

* 第一阶段：客户主机向服务器发送 SYN 报文段 （连接请求 **报文段**）：
    * SYN=1，ACK=0，选择一个初始的序号 x。
    * 不携带数据
* 第二阶段：服务器收到 SYN 报文段，若同意连接则答复 SYNACK 报文段（连接确认报文段）：
    * SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
        * 因为 TCP 是全双工通信，所以客户这边要有自己的初始序列号 x ，服务器那边也要有自己的初始序列号 y ，以后通信各自 x+，y+
* 第三阶段： 客户机收到 SYNACK 报文段后，答复 ACK 报文段（确认报文段）
    * ACK = 1，确认号为 y+1，序号为 x+1。
    * SYN = 0，可携带数据

* 最后：服务器收到客户机的确认后，连接建立。

#### 2.2 TCP 三次握手的原因

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己接收正常，对方发送正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。

#### 2.3 TCP 连接管理：四次挥手机制 【客：FIN 控制报文段->服：ACK 报文段 （此时TCP半关闭）->服：FIN 控制报文段->客：ACK 报文段】

![](https://github.com/CyC2018/CS-Notes/raw/master/pics/f87afe72-c2df-4c12-ac03-9b8d581a8af8.jpg)

以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，**因为 ACK 在连接建立之后都为 1。**

* 第一次：客户机向服务器发送 FIN 控制报文段（连接释放报文段）：
    * FIN=1
    * 并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。

* 第二次：服务器收到之后发出确认报文段。
    * 服务器进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户机到服务器的连接释放（服务器能向客户机发送数据，但是客户机不能向服务器发送数据）。
* 客户机收到服务器的确认后，进入FIN-WAIT-2（终止等待2）状态，等待服务器发出的连接释放报文段。

* 第三次：当服务器不再需要连接时，发送 FIN 控制报文段（连接释放报文段）
    * FIN=1。

* 第四次：客户机收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
    * **TIME_WAIT** ：客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

        - 确保最后一个确认报文能够到达。如果服务器没收到客户机发送来的确认报文，那么就会重新发送连接释放请求报文，客户机等待一段时间就是为了处理这种情况的发生。（所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。）

        - 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。？

* 最后： 服务器收到客户机的确认后释放连接。

#### 2.4 TCP 四次挥手的原因
任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

上面讲的比较概括，推荐一篇讲的比较细致的文章：https://blog.csdn.net/qzcsu/article/details/72861891

* 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT（关闭等待） 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

### 3、点对点     （是单个发送方与单个接收方的连接）
### 4、全双工服务 （同一连接中能传输双向数据流）
### 5、双方都有发送和接收缓存  （从这里发/收数据）
### 6、提供可靠数据传输 （不错、不丢、不乱）【通过确认/重传来实现】
####  TCP 在 IP 层提供的不可靠服务基础上实现了可靠数据传输服务。
#### 1）确认到达 + 超时重传和快速重传：防止丢包
##### 1.1）采用累积确认【ACK（n）,确认号n之前的都已经接收了。（确认号是期待收到的下一个序号）】
* 滑动窗口提高了传输效率，同时起到流量控制的作用。

![](https://github.com/CyC2018/CS-Notes/raw/master/pics/a3253deb-8d21-40a1-aae4-7d178e4aa319.jpg)

##### 1.2）超时重传 ： 如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段
* 超时时间的确定：
    * 况一：收到上层应用数据和收到ACK时会重启定时器，则超时时间为  【有实测样本RTT的参加】
        * 超时时间 = 加权平均RTT + 4 * 偏差RTT
            * 加权平均RTT = （1-a）* 加权平均 RTT + a * 样本RTT   [a 参考值为 0.125]
            * 偏差RTT = （1-b）* 偏差RTT + b * |加权平均 RTT - 样本RTT|  [b 参考值为0.25]
        * 往返时间RTT ：指一个短分组从客户到服务器然后再返回客户所花的时间。
    * 况二：当超时了，重传引起重启定时器，此时超时时间设为上次值得2倍
###### 1.2.1 使用单一重传定时器【用于超时重传一个分组】
* 仅为最早的未被确认的报文段设置定时器
##### 1.3） 快速重传 【收到3个冗余ACK，则快速重传】 
#### 3）分组序列号：确保数据包的顺序
#### 4）检验和：来检测在一个传输分组中的比特错误

### 8、提供流量控制【为了控制发送方发送速率，保证接收方来得及接收】

* 接收方发送的确认报文中的窗口字段可以用来 **控制发送方窗口大小**，从而影响发送方的发送速率【窗口值rwdn用于指示该接收方还有多少缓存空间】。将窗口字段设置为 0，则发送方不能发送数据。

### 9、提供拥塞控制 【为了降低整个网络的拥塞程度】
#### 9.1 为什么要有拥塞控制？——网络拥塞，导致分组会丢失，分组丢失导致重传，重传导致网络更加拥塞
* 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

![](https://github.com/CyC2018/CS-Notes/raw/master/pics/51e2ed95-65b8-4ae9-8af3-65602d452a25.jpg)

#### 9.2 TCP 主要通过四个算法来进行拥塞控制：慢启动、拥塞避免、快重传、快恢复。【共有 慢启动、拥塞避免、快恢复三种状态】

* 拥塞窗口cwnd：TCP 连接的每一端都是由一个接受缓存、一个发送缓存、和几个变量（LastByteSend、LastByteAcked等）组成。运行在发送方的拥塞控制机制需要跟踪一个额外的变量，即拥塞窗口cwnd。注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。
* 在一个发送方中尚未确认的数据量不能超过 cwnd 和 rwnd 中的最小值，即
    * **LastByteSend - LastByteAcked <= min {cwnd , rwnd}**

* 为了便于讨论，做如下假设：

    - 接收方有足够大的接收缓存，因此不会发生流量控制；
    - 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

![](https://github.com/CyC2018/CS-Notes/raw/master/pics/910f613f-514f-4534-87dd-9b4699d59d31.png)

##### 9.2.1 慢启动与拥塞避免

* 慢启动的开始：送的最初执行慢启动，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...
* 慢启动的结束：
    * 况一：由于超时指示拥塞，重启慢启动
        * 发送方令慢启动阈值ssthresh = cwnd/2，且cwnd= 1来重启慢启动
    * 况二：由于cwnd >= ssthresh，进入拥塞避免
        * 拥塞避免是指：每次只将 cwnd 加1
    * 况三：当检测到3个冗余 ACK 时，执行快速重传并进入快速回复状态

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

##### 9.2.2 快重传与快恢复【收到3个冗余ACK则快重传，快恢复是指发送方令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。】

* 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M<sub>1</sub> 和 M<sub>2</sub>，此时收到 M<sub>4</sub>，应当发送对 M<sub>2</sub> 的确认。

* 快重传：在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M<sub>2</sub>，则 M<sub>3</sub> 丢失，立即重传 M<sub>3</sub>。

* 快恢复：
    * 令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。【因为在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复。】

* 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。

![](https://github.com/CyC2018/CS-Notes/raw/master/pics/f61b5419-c94a-4df1-8d4d-aed9ae8cc6d5.png)
##### 9.2.3 TCP 拥塞控制方式 常常被称为 加性增、乘性减（AIMD）拥塞控制方式
* 因为当是3个冗余ACK时（不是超时），每个RTT内cwnd 线性（加性）增加 1个MSS(最大段长度)，然后出现3个冗余ACK时，cwnd 减半（乘性减）。
